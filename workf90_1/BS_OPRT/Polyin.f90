! Dear Mao,

! Saw your note in NA-digest.  Here's a couple routines from 
! years ago when Marsha Berger and I were doing Cartesian grid 
! methods for Euler equations. subroutine polyin computes the 
! intersection.  The makep routine gives a clue as to how the 
! polygons are stored.

! - Randy

module polygon_intersection
! This module computes intersection of two convex polygons.

use tools
! 'tools.f90'

implicit none

type polygon
 real(8), dimension(10) :: x, y
 integer :: size
end type polygon
! A polygon is defined by a set of vertices and its size, the 
! number of the vertices.

public polyin


contains


subroutine polyin(p1,p2,p3,close_1,area)
implicit none

type(polygon), intent(in) :: p1, p2
character*6, intent(in) :: close_1
type(polygon), intent(out) :: p3
real(8), intent(out) :: area

! Find the intersection of polygons p1 and p2.  Usually one is a
! wave and the other a grid cell.
! The intersection polygon is stored in p3 (which may overwrite
! p1 or p2 if desired).  The area of the intersection is stored
! in 'area'.
! The intersection is found by intersecting p2 with the half space
! determined by the first two vertices of p1.  This polygon is then
! intersected with the half space determined by the next two 
! vertices of p1, and so on.
! p2 should be a closed polygon, but p1 need not be.  In particular,
! p1 may be a half space with only two vertices.  The routine is
! used in this manner to find the intersection of a wave with the
! half space generated by a boundary segment, for example.
!
real(8), dimension(11,3) :: x, y
real(8) :: x1, x2, y1, y2, delx, dely, s, det, alf, epsilon
integer :: size_1, size_2, size_3, i, j, k, icase
logical :: in,inold

! The variable 'close_1' is for user to determine if the first 
! input polygon should be closed. The possible values for this 
! variable are 'opened' and 'closed'.

real(8), dimension(:,:), allocatable :: pt

epsilon=1.0d-6
if (p1%size.eq.0.or.p2%size.eq.0) then  
 p3%size=0; goto 80	             
! One of the polygons is empty.
endif

size_1=p1%size
do i=1,size_1; x(i,1) = p1%x(i); y(i,1) = p1%y(i); end do
if(close_1.eq.'closed') then
 x(size_1+1,1)=x(1,1); y(size_1+1,1)=y(1,1)
else
 size_1=size_1-1
end if

size_2=p2%size
do i=1,size_2; x(i,2) = p2%x(i); y(i,2) = p2%y(i); end do
x(size_2+1,2)=x(1,2); y(size_2+1,2)=y(1,2)

do i=1,size_1

 k = 0; size_3=0
! Initialize the intersection polygon 'p3'.
 
 x1 = x(i,1); y1 = y(i,1); x2 = x(i+1,1); y2 = y(i+1,1)
 delx = x1 - x2; dely = y2 - y1

 do j=1,size_2+1

  s = dely*(x(j,2)-x1) + delx*(y(j,2)-y1)  
! Variable 's' checks whether the vertex of the second polygon is 
! inside the half space containing the first polygon.                           
  in = (s.gt.0.d0)

  if (j.eq.1.and.in) goto 2
  if (j.eq.1) goto 3
  icase = 1 
  if (in .and. inold) icase = 2
  if (.not.in.and..not.inold) icase = 3 
  goto (1,2,3) icase                    
! When both the old and current vertices of the second polygon are 
! in the half space of the first polygon, the current vertex is 
! added to the intersection polygon, when the both the old and 
! current vertices are out of the half space of the first polygon, 
! the do loop cycles, and when the vertices are in different half 
! spaces, the intersection point is to found and to be added to 
! the intersection polygon. 

! Calculate intersection of lines:
1 continue
  det=(x2-x1)*(y(j-1,2)-y(j,2))-(x(j-1,2)-x(j,2))*(y2-y1)
  if (dabs(det).lt.epsilon) goto 2
  alf=((x(j-1,2)-x1)*(y(j-1,2)-y(j,2))-(x(j-1,2)-x(j,2))*(y(j-1,2)-y1))/det
  k = k+1
  x(k,3) = x1 + alf*(x2-x1); y(k,3) = y1 + alf*(y2-y1)
  if (k.eq.1) goto 7
  if (x(k,3).eq.x(k-1,3) .and. y(k,3).eq.y(k-1,3)) k = k-1
  7 if(.not.in) goto 3

  2 continue
  k = k+1
  x(k,3) = x(j,2); y(k,3) = y(j,2)

  3 continue
  inold = in

 12 end do
 
 20 continue
 if (x(k,3).ne.x(1,3) .or. y(k,3).ne.y(1,3)) then
  k = k+1
  x(k,3) = x(1,3); y(k,3) = y(1,3)
 end if
 size_3=k-1
! Close the intersection polygon by connecting the first and last 
! vortices.

 do j=1, 10; x(j,2)=x(j,3); y(j,2)=y(j,3); end do 
 size_2=size_3
! Pass the data of the intersection polygon back to the second 
! polygon for the next run of the do-loop.

end do

do i=1,size_2; p3%x(i)=x(i,2); p3%y(i)=y(i,2); end do
p3%size=size_2
! The final result.

80 continue
allocate(pt(p3%size,2))
do i=1,p3%size
 pt(i,1)=p3%x(i); pt(i,2)=p3%y(i)
end do
area=area_of_polygon(pt,p3%size)
deallocate(pt)

end subroutine polyin

end module polygon_intersection